# Î©ÄÌã∞ ÌîåÎû´Ìèº EXE ÎπåÎìú ÏãúÏä§ÌÖú

## üí∞ Í∞ÄÍ≤© Ï†ïÏ±Ö ÏóÖÎç∞Ïù¥Ìä∏

### ÏÉàÎ°úÏö¥ Í∞ÄÍ≤© Íµ¨Ï°∞
```
- FREE: $0/Ïõî (10Í∞ú ÌååÏùº, Í∏∞Î≥∏ Î∂ÑÏÑù)
- PRO: $9.9/Ïõî (Î¨¥Ï†úÌïú ÌååÏùº, Í≥†Í∏â Î∂ÑÏÑù, 3Í∞ú ÎîîÎ∞îÏù¥Ïä§)
- ENTERPRISE: $49/Ïõî (ÌåÄ Í¥ÄÎ¶¨, Ïò®ÌîÑÎ†àÎØ∏Ïä§, Î¨¥Ï†úÌïú ÎîîÎ∞îÏù¥Ïä§)
```

### Stripe Í∞ÄÍ≤© ID ÏóÖÎç∞Ïù¥Ìä∏
```javascript
const PRICE_CONFIG = {
  PRO: {
    priceId: process.env.STRIPE_PRICE_ID_PRO_MONTHLY, // $9.9/Ïõî
    amount: 990, // $9.90 (ÏÑºÌä∏ Îã®ÏúÑ)
    currency: 'usd',
    interval: 'month'
  },
  ENTERPRISE: {
    priceId: process.env.STRIPE_PRICE_ID_ENTERPRISE_MONTHLY, // $49/Ïõî
    amount: 4900, // $49.00
    currency: 'usd', 
    interval: 'month'
  }
};
```

## üñ•Ô∏è Î©ÄÌã∞ ÌîåÎû´Ìèº ÎπåÎìú Ï†ÑÎûµ

### 1. ÌÉÄÍ≤ü ÌîåÎû´Ìèº
```
1. Windows (x64) - .exe
2. macOS (Intel + Apple Silicon) - .app + .dmg
3. Linux (x64) - .AppImage
```

### 2. ÎπåÎìú ÎèÑÍµ¨ ÏÑ†ÌÉù

#### Electron (Ï∂îÏ≤ú)
```javascript
// package.json
{
  "main": "src/electron/main.js",
  "scripts": {
    "electron:dev": "concurrently \"npm run web:dev\" \"electron .\"",
    "electron:build": "npm run web:build && electron-builder",
    "build:windows": "electron-builder --windows",
    "build:mac": "electron-builder --mac",
    "build:linux": "electron-builder --linux"
  },
  "build": {
    "appId": "com.workflowvisualizer.desktop",
    "productName": "Workflow Visualizer",
    "directories": {
      "output": "dist"
    },
    "files": [
      "dist/**/*",
      "src/electron/**/*",
      "node_modules/**/*"
    ],
    "win": {
      "target": [
        {
          "target": "nsis",
          "arch": ["x64"]
        }
      ],
      "icon": "assets/icon.ico",
      "publisherName": "Workflow Visualizer Inc."
    },
    "mac": {
      "target": [
        {
          "target": "dmg",
          "arch": ["x64", "arm64"]
        }
      ],
      "icon": "assets/icon.icns",
      "category": "public.app-category.developer-tools"
    },
    "linux": {
      "target": [
        {
          "target": "AppImage",
          "arch": ["x64"]
        }
      ],
      "icon": "assets/icon.png",
      "category": "Development"
    }
  }
}
```

### 3. Electron Î©îÏù∏ ÌîÑÎ°úÏÑ∏Ïä§ Íµ¨Ï°∞

```javascript
// src/electron/main.js
const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const path = require('path');
const isDev = process.env.NODE_ENV === 'development';

class WorkflowVisualizerApp {
  constructor() {
    this.mainWindow = null;
    this.licenseManager = new LicenseManager();
    this.setupEventHandlers();
  }

  async createMainWindow() {
    this.mainWindow = new BrowserWindow({
      width: 1400,
      height: 900,
      minWidth: 800,
      minHeight: 600,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, 'preload.js')
      },
      icon: this.getAppIcon(),
      show: false // ÎùºÏù¥ÏÑ†Ïä§ Í≤ÄÏ¶ù ÌõÑ ÌëúÏãú
    });

    // ÎùºÏù¥ÏÑ†Ïä§ Í≤ÄÏ¶ù
    const isLicenseValid = await this.licenseManager.validateLicense();
    if (!isLicenseValid) {
      this.showLicenseDialog();
      return;
    }

    // Î©îÏù∏ Ïï± Î°úÎìú
    if (isDev) {
      this.mainWindow.loadURL('http://localhost:3000');
      this.mainWindow.webContents.openDevTools();
    } else {
      this.mainWindow.loadFile(path.join(__dirname, '../dist/index.html'));
    }

    this.mainWindow.show();
  }

  getAppIcon() {
    const platform = process.platform;
    if (platform === 'win32') {
      return path.join(__dirname, '../assets/icon.ico');
    } else if (platform === 'darwin') {
      return path.join(__dirname, '../assets/icon.icns');
    } else {
      return path.join(__dirname, '../assets/icon.png');
    }
  }

  setupEventHandlers() {
    app.whenReady().then(() => this.createMainWindow());
    
    app.on('window-all-closed', () => {
      if (process.platform !== 'darwin') {
        app.quit();
      }
    });

    app.on('activate', () => {
      if (BrowserWindow.getAllWindows().length === 0) {
        this.createMainWindow();
      }
    });

    // IPC Ìï∏Îì§Îü¨
    ipcMain.handle('license:validate', async (event, licenseKey) => {
      return await this.licenseManager.validateLicense(licenseKey);
    });

    ipcMain.handle('analysis:run', async (event, analysisData) => {
      return await this.runSecureAnalysis(analysisData);
    });
  }
}

new WorkflowVisualizerApp();
```

## üîê Ïö¥ÏòÅÏ≤¥Ï†úÎ≥Ñ ÎùºÏù¥ÏÑ†Ïä§ ÏãúÏä§ÌÖú

### 1. ÎîîÎ∞îÏù¥Ïä§ ÌïëÍ±∞ÌîÑÎ¶∞ÌåÖ (OSÎ≥Ñ)

```javascript
// src/electron/license/DeviceFingerprinting.js
const os = require('os');
const crypto = require('crypto');

class DeviceFingerprinting {
  generateFingerprint() {
    const platform = process.platform;
    
    switch (platform) {
      case 'win32':
        return this.generateWindowsFingerprint();
      case 'darwin':
        return this.generateMacFingerprint();
      case 'linux':
        return this.generateLinuxFingerprint();
      default:
        return this.generateGenericFingerprint();
    }
  }

  generateWindowsFingerprint() {
    const { execSync } = require('child_process');
    
    try {
      // Windows Í≥†Ïú† Ï†ïÎ≥¥ ÏàòÏßë
      const cpuId = execSync('wmic cpu get ProcessorId /value', { encoding: 'utf8' })
        .split('=')[1]?.trim();
      const motherboardSerial = execSync('wmic baseboard get SerialNumber /value', { encoding: 'utf8' })
        .split('=')[1]?.trim();
      const biosSerial = execSync('wmic bios get SerialNumber /value', { encoding: 'utf8' })
        .split('=')[1]?.trim();
      
      const hwInfo = {
        platform: 'win32',
        cpuId: cpuId || 'unknown',
        motherboardSerial: motherboardSerial || 'unknown',
        biosSerial: biosSerial || 'unknown',
        hostname: os.hostname(),
        arch: os.arch()
      };
      
      return this.hashFingerprint(hwInfo);
    } catch (error) {
      return this.generateGenericFingerprint();
    }
  }

  generateMacFingerprint() {
    const { execSync } = require('child_process');
    
    try {
      // macOS Í≥†Ïú† Ï†ïÎ≥¥ ÏàòÏßë
      const serialNumber = execSync('system_profiler SPHardwareDataType | grep "Serial Number"', { encoding: 'utf8' })
        .split(':')[1]?.trim();
      const macAddress = execSync('ifconfig en0 | grep ether', { encoding: 'utf8' })
        .split(' ')[1]?.trim();
      const hwUuid = execSync('system_profiler SPHardwareDataType | grep "Hardware UUID"', { encoding: 'utf8' })
        .split(':')[1]?.trim();
      
      const hwInfo = {
        platform: 'darwin',
        serialNumber: serialNumber || 'unknown',
        macAddress: macAddress || 'unknown',
        hwUuid: hwUuid || 'unknown',
        hostname: os.hostname(),
        arch: os.arch()
      };
      
      return this.hashFingerprint(hwInfo);
    } catch (error) {
      return this.generateGenericFingerprint();
    }
  }

  generateLinuxFingerprint() {
    const { execSync } = require('child_process');
    
    try {
      // Linux Í≥†Ïú† Ï†ïÎ≥¥ ÏàòÏßë
      const machineId = execSync('cat /etc/machine-id || cat /var/lib/dbus/machine-id', { encoding: 'utf8' })
        .trim();
      const cpuInfo = execSync('cat /proc/cpuinfo | grep "processor\\|model name" | head -2', { encoding: 'utf8' });
      const dmidecode = execSync('sudo dmidecode -s system-serial-number 2>/dev/null || echo "unknown"', { encoding: 'utf8' })
        .trim();
      
      const hwInfo = {
        platform: 'linux',
        machineId: machineId || 'unknown',
        cpuInfo: crypto.createHash('md5').update(cpuInfo).digest('hex').substring(0, 8),
        systemSerial: dmidecode || 'unknown',
        hostname: os.hostname(),
        arch: os.arch()
      };
      
      return this.hashFingerprint(hwInfo);
    } catch (error) {
      return this.generateGenericFingerprint();
    }
  }

  generateGenericFingerprint() {
    const hwInfo = {
      platform: process.platform,
      hostname: os.hostname(),
      arch: os.arch(),
      cpus: os.cpus().length,
      totalmem: os.totalmem(),
      userInfo: os.userInfo().username
    };
    
    return this.hashFingerprint(hwInfo);
  }

  hashFingerprint(hwInfo) {
    const fingerprint = crypto
      .createHash('sha256')
      .update(JSON.stringify(hwInfo, Object.keys(hwInfo).sort()))
      .digest('hex')
      .substring(0, 16);
    
    return fingerprint;
  }
}

module.exports = DeviceFingerprinting;
```

### 2. ÎùºÏù¥ÏÑ†Ïä§ Í¥ÄÎ¶¨Ïûê

```javascript
// src/electron/license/LicenseManager.js
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');
const os = require('os');

class LicenseManager {
  constructor() {
    this.deviceFingerprinting = new DeviceFingerprinting();
    this.licenseFile = this.getLicenseFilePath();
    this.serverUrl = process.env.LICENSE_SERVER_URL || 'https://api.workflow-visualizer.com';
  }

  getLicenseFilePath() {
    const platform = process.platform;
    let appDataPath;
    
    if (platform === 'win32') {
      appDataPath = path.join(os.homedir(), 'AppData', 'Roaming', 'WorkflowVisualizer');
    } else if (platform === 'darwin') {
      appDataPath = path.join(os.homedir(), 'Library', 'Application Support', 'WorkflowVisualizer');
    } else {
      appDataPath = path.join(os.homedir(), '.config', 'workflow-visualizer');
    }
    
    return path.join(appDataPath, 'license.dat');
  }

  async validateLicense(newLicenseKey = null) {
    try {
      let licenseKey = newLicenseKey;
      
      if (!licenseKey) {
        // Ï†ÄÏû•Îêú ÎùºÏù¥ÏÑ†Ïä§ ÌÇ§ ÏùΩÍ∏∞
        const storedLicense = await this.readStoredLicense();
        if (!storedLicense) {
          return { valid: false, reason: 'NO_LICENSE' };
        }
        licenseKey = storedLicense.key;
      }

      // 1. ÎùºÏù¥ÏÑ†Ïä§ ÌÇ§ Ìè¨Îß∑ Í≤ÄÏ¶ù
      if (!this.validateKeyFormat(licenseKey)) {
        return { valid: false, reason: 'INVALID_FORMAT' };
      }

      // 2. Ïò®ÎùºÏù∏ Í≤ÄÏ¶ù
      const onlineValidation = await this.validateOnline(licenseKey);
      if (onlineValidation.valid) {
        await this.storeLicense(licenseKey, onlineValidation.data);
        return { valid: true, data: onlineValidation.data };
      }

      // 3. Ïò®ÎùºÏù∏ Í≤ÄÏ¶ù Ïã§Ìå® Ïãú Ïò§ÌîÑÎùºÏù∏ Í≤ÄÏ¶ù
      const offlineValidation = await this.validateOffline();
      return offlineValidation;

    } catch (error) {
      console.error('ÎùºÏù¥ÏÑ†Ïä§ Í≤ÄÏ¶ù Ïò§Î•ò:', error);
      return { valid: false, reason: 'VALIDATION_ERROR' };
    }
  }

  validateKeyFormat(licenseKey) {
    // WV2024-AB7CD-E9F12-GH3IJ-K4L56 ÌòïÏãù Í≤ÄÏ¶ù
    const keyPattern = /^WV2024-[A-Z0-9]{5}-[A-Z0-9]{5}-[A-Z0-9]{5}-[A-Z0-9]{5}$/;
    return keyPattern.test(licenseKey);
  }

  async validateOnline(licenseKey) {
    try {
      const deviceFingerprint = this.deviceFingerprinting.generateFingerprint();
      
      const response = await fetch(`${this.serverUrl}/desktop/license/validate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': `WorkflowVisualizer-Desktop/${this.getAppVersion()}`,
        },
        body: JSON.stringify({
          licenseKey,
          deviceFingerprint,
          platform: process.platform,
          appVersion: this.getAppVersion()
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const result = await response.json();
      return result;

    } catch (error) {
      console.warn('Ïò®ÎùºÏù∏ ÎùºÏù¥ÏÑ†Ïä§ Í≤ÄÏ¶ù Ïã§Ìå®:', error.message);
      return { valid: false, reason: 'NETWORK_ERROR' };
    }
  }

  async validateOffline() {
    try {
      const storedLicense = await this.readStoredLicense();
      if (!storedLicense) {
        return { valid: false, reason: 'NO_OFFLINE_LICENSE' };
      }

      // ÌÜ†ÌÅ∞ ÎßåÎ£å Í≤ÄÏÇ¨
      if (Date.now() > storedLicense.expiresAt) {
        return { valid: false, reason: 'OFFLINE_TOKEN_EXPIRED' };
      }

      // ÎîîÎ∞îÏù¥Ïä§ Î∞îÏù∏Îî© Í≤ÄÏÇ¨
      const currentFingerprint = this.deviceFingerprinting.generateFingerprint();
      if (storedLicense.deviceFingerprint !== currentFingerprint) {
        return { valid: false, reason: 'DEVICE_MISMATCH' };
      }

      // ÏµúÎåÄ Ïò§ÌîÑÎùºÏù∏ Í∏∞Í∞Ñ Í≤ÄÏÇ¨ (30Ïùº)
      const maxOfflineMs = 30 * 24 * 60 * 60 * 1000;
      if (Date.now() - storedLicense.lastOnlineCheck > maxOfflineMs) {
        return { valid: false, reason: 'OFFLINE_PERIOD_EXCEEDED' };
      }

      return { valid: true, data: storedLicense };

    } catch (error) {
      return { valid: false, reason: 'OFFLINE_VALIDATION_ERROR' };
    }
  }

  async storeLicense(licenseKey, validationData) {
    try {
      const licenseData = {
        key: licenseKey,
        deviceFingerprint: this.deviceFingerprinting.generateFingerprint(),
        validUntil: validationData.validUntil,
        planType: validationData.planType,
        maxDevices: validationData.maxDevices,
        lastOnlineCheck: Date.now(),
        expiresAt: Date.now() + (30 * 24 * 60 * 60 * 1000), // 30Ïùº ÌõÑ ÎßåÎ£å
        storedAt: Date.now()
      };

      // ÏïîÌò∏ÌôîÌïòÏó¨ Ï†ÄÏû•
      const encryptedData = this.encryptLicenseData(licenseData);
      
      // ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
      const licenseDir = path.dirname(this.licenseFile);
      await fs.mkdir(licenseDir, { recursive: true });
      
      // ÌååÏùº Ï†ÄÏû•
      await fs.writeFile(this.licenseFile, encryptedData);

    } catch (error) {
      console.error('ÎùºÏù¥ÏÑ†Ïä§ Ï†ÄÏû• Ïò§Î•ò:', error);
      throw error;
    }
  }

  async readStoredLicense() {
    try {
      const encryptedData = await fs.readFile(this.licenseFile, 'utf8');
      return this.decryptLicenseData(encryptedData);
    } catch (error) {
      return null;
    }
  }

  encryptLicenseData(data) {
    const key = this.getDerivedKey();
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher('aes-256-cbc', key);
    
    let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return iv.toString('hex') + ':' + encrypted;
  }

  decryptLicenseData(encryptedData) {
    const key = this.getDerivedKey();
    const parts = encryptedData.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const encryptedText = parts[1];
    
    const decipher = crypto.createDecipher('aes-256-cbc', key);
    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return JSON.parse(decrypted);
  }

  getDerivedKey() {
    // ÎîîÎ∞îÏù¥Ïä§Î≥Ñ Í≥†Ïú† ÌÇ§ ÏÉùÏÑ±
    const fingerprint = this.deviceFingerprinting.generateFingerprint();
    return crypto.createHash('sha256').update(fingerprint + 'WORKFLOW_VISUALIZER_2024').digest('hex');
  }

  getAppVersion() {
    const packageJson = require('../../package.json');
    return packageJson.version;
  }
}

module.exports = LicenseManager;
```

## üîß ÎπåÎìú ÏÑ§Ï†ï Î∞è Î∞∞Ìè¨

### 1. GitHub Actions ÏõåÌÅ¨ÌîåÎ°úÏö∞

```yaml
# .github/workflows/desktop-build.yml
name: Desktop App Build

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build:
    strategy:
      matrix:
        os: [windows-latest, macos-latest, ubuntu-latest]
    
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build web app
        run: npm run build
      
      - name: Build Windows app
        if: matrix.os == 'windows-latest'
        run: npm run build:windows
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Build macOS app
        if: matrix.os == 'macos-latest'
        run: npm run build:mac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CSC_LINK: ${{ secrets.MAC_CERTIFICATE }}
          CSC_KEY_PASSWORD: ${{ secrets.MAC_CERTIFICATE_PASSWORD }}
      
      - name: Build Linux app
        if: matrix.os == 'ubuntu-latest'
        run: npm run build:linux
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: desktop-app-${{ matrix.os }}
          path: dist/
```

### 2. ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏä§ÌÖú

```javascript
// src/electron/updater/AutoUpdater.js
const { autoUpdater } = require('electron-updater');
const { dialog } = require('electron');

class AutoUpdater {
  constructor(mainWindow) {
    this.mainWindow = mainWindow;
    this.setupUpdater();
  }

  setupUpdater() {
    // ÏóÖÎç∞Ïù¥Ìä∏ ÏÑúÎ≤Ñ ÏÑ§Ï†ï
    autoUpdater.setFeedURL({
      provider: 'github',
      owner: 'your-org',
      repo: 'workflow-visualizer',
      private: false
    });

    // ÏóÖÎç∞Ïù¥Ìä∏ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
    autoUpdater.on('checking-for-update', () => {
      console.log('ÏóÖÎç∞Ïù¥Ìä∏ ÌôïÏù∏ Ï§ë...');
    });

    autoUpdater.on('update-available', (info) => {
      console.log('ÏóÖÎç∞Ïù¥Ìä∏ Î∞úÍ≤¨:', info.version);
      this.showUpdateDialog(info);
    });

    autoUpdater.on('update-not-available', () => {
      console.log('ÏµúÏã† Î≤ÑÏ†ÑÏûÖÎãàÎã§.');
    });

    autoUpdater.on('error', (err) => {
      console.error('ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò:', err);
    });

    autoUpdater.on('download-progress', (progressObj) => {
      const logMessage = `Îã§Ïö¥Î°úÎìú ÏßÑÌñâÎ•†: ${progressObj.percent}%`;
      console.log(logMessage);
      this.mainWindow.webContents.send('update-progress', progressObj);
    });

    autoUpdater.on('update-downloaded', () => {
      this.showRestartDialog();
    });
  }

  async checkForUpdates() {
    try {
      await autoUpdater.checkForUpdatesAndNotify();
    } catch (error) {
      console.error('ÏóÖÎç∞Ïù¥Ìä∏ ÌôïÏù∏ Ïã§Ìå®:', error);
    }
  }

  showUpdateDialog(updateInfo) {
    const response = dialog.showMessageBoxSync(this.mainWindow, {
      type: 'question',
      buttons: ['ÏóÖÎç∞Ïù¥Ìä∏', 'ÎÇòÏ§ëÏóê'],
      defaultId: 0,
      message: 'ÏÉà ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä ÏûàÏäµÎãàÎã§',
      detail: `Î≤ÑÏ†Ñ ${updateInfo.version}Ïù¥ Î∞úÍ≤¨ÎêòÏóàÏäµÎãàÎã§. ÏßÄÍ∏à Îã§Ïö¥Î°úÎìúÌïòÏãúÍ≤†ÏäµÎãàÍπå?`
    });

    if (response === 0) {
      autoUpdater.downloadUpdate();
    }
  }

  showRestartDialog() {
    const response = dialog.showMessageBoxSync(this.mainWindow, {
      type: 'question',
      buttons: ['Ïû¨ÏãúÏûë', 'ÎÇòÏ§ëÏóê'],
      defaultId: 0,
      message: 'ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å',
      detail: 'ÏóÖÎç∞Ïù¥Ìä∏ ÏÑ§ÏπòÎ•º ÏôÑÎ£åÌïòÎ†§Î©¥ Ïï±ÏùÑ Ïû¨ÏãúÏûëÌï¥Ïïº Ìï©ÎãàÎã§.'
    });

    if (response === 0) {
      autoUpdater.quitAndInstall();
    }
  }
}

module.exports = AutoUpdater;
```

## üì¶ ÏµúÏ¢Ö Î∞∞Ìè¨ Ìå®ÌÇ§ÏßÄ

### ÏòàÏÉÅ Î∞∞Ìè¨ ÌååÏùºÎì§:
```
# Windows
WorkflowVisualizer-Setup-1.0.0.exe (ÏïΩ 150MB)

# macOS  
WorkflowVisualizer-1.0.0.dmg (ÏïΩ 200MB)
WorkflowVisualizer-1.0.0-arm64.dmg (Apple Silicon)

# Linux
WorkflowVisualizer-1.0.0.AppImage (ÏïΩ 180MB)
```

### Îã§Ïö¥Î°úÎìú ÌéòÏù¥ÏßÄ Íµ¨ÏÑ±:
```markdown
## Workflow Visualizer Desktop - $9.9/Ïõî

### ÏßÄÏõê ÌîåÎû´Ìèº:
- ü™ü Windows 10/11 (64-bit)
- üçé macOS 10.15+ (Intel & Apple Silicon)
- üêß Linux (Ubuntu 18.04+, AppImage)

### Í∏∞Îä•:
- ‚úÖ Ïò§ÌîÑÎùºÏù∏ Î∂ÑÏÑù (30ÏùºÍ∞Ñ)
- ‚úÖ Î¨¥Ï†úÌïú ÌîÑÎ°úÏ†ùÌä∏
- ‚úÖ Í≥†Í∏â ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù
- ‚úÖ 3Í∞ú ÎîîÎ∞îÏù¥Ïä§ ÎèôÏãú ÏÇ¨Ïö©
- ‚úÖ ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏
```

Ïù¥Î†áÍ≤å **$9.9/Ïõî**Î°ú **3Í∞ú ÌîåÎû´Ìèº EXE**Î•º Ï†úÍ≥µÌïòÎ©¥ÏÑú **ÏïàÏ†ÑÌïú ÎùºÏù¥ÏÑ†Ïä§ ÏãúÏä§ÌÖú**ÏùÑ Íµ¨Ï∂ïÌï† Ïàò ÏûàÏäµÎãàÎã§!